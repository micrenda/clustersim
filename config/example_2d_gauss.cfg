#
# This file contains the setting to be used for the simulation
#
#
simulation:
{
# Specify the basename. A director starting with this name will be created containing all the output files
basename="example2d_gauss"

# Specify the dimensions of the system
# values: 1D, 2D, 3D, 4D, 5D ...
dimensions="2D"

# Specify the dimension of the container in pixels
container_size=[1200, 800]

# Specify how many timeframe must be simulates
duration=200

# Specify if the simulation must stop when the volume is 100% filled (does not wait until t = duration-1)
# The value must be between 0.0 and 1.0 (ie: 0.9 => 90%)
stop_when_volume_is=0.9998

# Specify the rule to follow to grow the clusters. By default this mode is disabled, meaning that the cluster will grow until it meet another cluster.
# The avrami mode is a pure theoretical model and it will allow every cluter to grow above another cluster (every cluster is modelled as a wave and when two waves meet, it is possible to continue to grow).
avrami_mode = 0;

# Function to determinate how many new cluster to add at every timeframe
# Variables:
#   t   time frame (0 to duration-1)
#   s   total duration
#   d   dimensions of the system (1->1D, 2-> 2D, etc.)
#
# Examples:
#
# create 10 cluster at the beginning
# "if t = 0 then return 10 else return 0 end;"
#
# create 5 cluster at every time frame
# "return 5;"
#
# create clusters with a gaussian distribution in time
# "return gaussian(t, 10, s/2, s/8, 0)"
cluster_creation_func="return math.floor(gaussian(t, 40, s/2, s/8, 0));"

# Function to determinate how much will grow the radius of every cluster
#   i   current cluster id.
#   t   current time frame.
#   s   duration.
#   r   current cluster radius.
#   v   current cluster volume.
#   c   cluster creation time frame (0,1,...).
#   d   dimensions of the system (1 => 1D, 2 => 2D, etc.)
#
# Examples:
#
# To grow linear with 5 pixels:
# "return 5;"
#
# To grow only up to a given radius 50:
# "if r <= 50 then return 2 else return 0 end;"
#
# To grow half of the clusters with a speed and another half with another speed
# "if i % 2 == 0 then return 2 else return 3 end;"
cluster_grow_func="return 2;"

# Function to determinate where to positionate every new cluster
#
# It is possible to specify one these formats:
#
# To use the same formula for all axes:
#   cluster_position_func=""
# To use a different formula for every axis (up to 3):
#   cluster_position_func_x=""
#   cluster_position_func_y=""
#   cluster_position_func_z=""
# To use a different formula for every axis (more then 3 axis):
#   cluster_position_func_x1=""
#   cluster_position_func_x2=""
#   cluster_position_func_x3=""
#
# (if no formula is give, the points are placed randomly inside the container)
#
#
# Variables:
#   i   current cluster id.
#   j   counter that indicate the inserting order (start from 0 and is resetted at every timeframe).
#   t   current time frame.
#   s   total duration.
#   w   container size in the current dimension.
#   d   dimensions of the system (1 => 1D, 2 => 2D, etc.)
#
# Examples:
#
# To put them random in plane x,y
# cluster_position_func_x="return math.random(0, w-1)"
# cluster_position_func_y="return math.random(0, w-1)"
# cluster_position_func_z="return w/2;"
cluster_position_func="
	repeat
		r = math.random(0, w-1);
		a = math.random();
	until a <= gaussian(r, 1, w/2, w/8, 0);
	return r;"


# Contains some common functions that can be used by other functions
#
# Example: define the gaussian function according:
# http://en.wikipedia.org/wiki/Gaussian_function
common_func_1 = "function gaussian(x, a, b, c, d) return a * math.exp(- (x - b)^2 / (2*c^2))+d; end;"
}

# Specify which projections must be rendered
render_1:
{
name   = "rainbow"
axis_1 = "x"
axis_2 = "y"
cuts   = ""
color_scheme = "RANDOM_ACID"
}

render_2:
{
name   = "by_age"
axis_1 = "x"
axis_2 = "y"
cuts   = ""
color_scheme = "GRADIENT_AGE"
color_1      = 0x99daff
color_2      = 0xf2647d
}

render_3:
{
name   = "by_radius"
axis_1 = "x"
axis_2 = "y"
cuts   = ""
color_scheme = "GRADIENT_RADIUS"
color_1      = 0x99daff
color_2      = 0x001380
}

render_4:
{
name   = "by_born"
axis_1 = "x"
axis_2 = "y"
cuts   = ""
color_scheme = "GRADIENT_BIRTH"
color_1      = 0x99daff
color_2      = 0x001380
}
